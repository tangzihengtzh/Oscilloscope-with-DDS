module wave_draw_rgb565 #(
    parameter integer H_VALID = 800,
    parameter integer V_VALID = 480,
    // 将 8bit 放大：y_level = (sample << Y_GAIN_SHIFT)，默认 0 不放大
    parameter integer Y_GAIN_SHIFT = 0,
    // 垂直偏置（像素，正值向上）
    parameter integer Y_BIAS = 0,
    // 颜色
    parameter [15:0] WAVE_COLOR = 16'hF800,
    parameter [15:0] BG_COLOR   = 16'h0000
)(
    input  wire        pclk,
    input  wire        rst_n,
    input  wire        lcd_de,
    input  wire [10:0] x,
    input  wire [10:0] y,
    input  wire [7:0]  sample_8b,
    output reg  [15:0] pixel_out
);
// wave_draw_rgb565.v —— 8bit 样本映射为屏幕 Y，仅点亮该 Y 的像素
    // 将 0..255 映射到 0..(V_VALID-1)，顶部为 255（直觉：高电平在屏幕上方）
    // y_target = (V_VALID-1) - floor( sample * (V_VALID-1) / 255 ) + Y_BIAS
    // 用近似：/255 ≈ /256 = >>8，误差可以忽略；若要更精确可改为乘以 257 再 >>16。
    wire [17:0] mult = sample_8b << Y_GAIN_SHIFT;   // 放大
    wire [17:0] y_scaled = (mult * V_VALID) >> 8;   // 约等于 * (V/256)
    wire [11:0] y_base   = (V_VALID-1) - y_scaled[10:0];

    // 应用偏置并裁剪
    wire signed [12:0] y_bias_applied = $signed({1'b0,y_base}) - $signed(Y_BIAS); // 正偏置向上
    wire [10:0] y_target = (y_bias_applied < 0) ? 11'd0 :
                           (y_bias_applied > (V_VALID-1)) ? (V_VALID-1) :
                           y_bias_applied[10:0];

    // 只在 y == y_target 且 DE 有效时着色
    always @(posedge pclk or negedge rst_n) begin
        if (!rst_n) begin
            pixel_out <= 16'h0000;
        end else if (lcd_de) begin
            pixel_out <= (y == y_target) ? WAVE_COLOR : BG_COLOR;
        end else begin
            pixel_out <= 16'h0000;
        end
    end
endmodule
